From d3b42e54c51b9867467728e89cee4fde81df4c46 Mon Sep 17 00:00:00 2001
From: Hu Shuai <hus.fnst@cn.fujitsu.com>
Date: Tue, 7 Sep 2021 16:26:52 +0800
Subject: [PATCH] Add RAID and BIOS clean steps for master nodes of IPI

Signed-off-by: Hu Shuai <hus.fnst@cn.fujitsu.com>
---
 ironic/resource_ironic_node_v1.go | 159 +++++++++++++++++++++++++++++-
 ironic/workflow.go                |   9 +-
 2 files changed, 163 insertions(+), 5 deletions(-)

diff --git a/ironic/resource_ironic_node_v1.go b/ironic/resource_ironic_node_v1.go
index 7823f5ec..98b95066 100644
--- a/ironic/resource_ironic_node_v1.go
+++ b/ironic/resource_ironic_node_v1.go
@@ -1,14 +1,24 @@
 package ironic
 
 import (
+	"encoding/json"
 	"fmt"
 	"log"
+	"strings"
 	"time"
 
 	"github.com/gophercloud/gophercloud"
 	"github.com/gophercloud/gophercloud/openstack/baremetal/v1/nodes"
 	"github.com/gophercloud/gophercloud/openstack/baremetal/v1/ports"
 	"github.com/hashicorp/terraform-plugin-sdk/helper/schema"
+	baremetalhost "github.com/metal3-io/baremetal-operator/apis/metal3.io/v1alpha1"
+	"github.com/metal3-io/baremetal-operator/pkg/bmc"
+	"github.com/metal3-io/baremetal-operator/pkg/provisioner/ironic"
+)
+
+const (
+	noRAIDInterface       string = "no-raid"
+	softwareRAIDInterface string = "agent"
 )
 
 // Schema resource definition for an Ironic node.
@@ -174,6 +184,16 @@ func resourceNodeV1() *schema.Resource {
 				Optional: true,
 				Computed: true,
 			},
+			"raid_config": {
+				Type:     schema.TypeString,
+				Optional: true,
+				Computed: true,
+			},
+			"bios_settings": {
+				Type:     schema.TypeString,
+				Optional: true,
+				Computed: true,
+			},
 		},
 	}
 }
@@ -237,7 +257,16 @@ func resourceNodeV1Create(d *schema.ResourceData, meta interface{}) error {
 
 	// Clean node
 	if d.Get("clean").(bool) {
-		if err := ChangeProvisionStateToTarget(client, d.Id(), "clean", nil, nil); err != nil {
+		if err := setRAIDConfig(client, d); err != nil {
+			return fmt.Errorf("fail to set raid config: %s", err)
+		}
+
+		var cleanSteps []nodes.CleanStep
+		if cleanSteps, err = buildManualCleaningSteps(d); err != nil {
+			return fmt.Errorf("fail to build raid clean steps: %s", err)
+		}
+
+		if err := ChangeProvisionStateToTarget(client, d.Id(), "clean", cleanSteps, nil); err != nil {
 			return fmt.Errorf("could not clean: %s", err)
 		}
 	}
@@ -585,3 +614,131 @@ func changePowerState(client *gophercloud.ServiceClient, d *schema.ResourceData,
 
 	return nil
 }
+
+// Call Ironic's API to send request to change a Node's RAID config.
+func setRAIDConfig(client *gophercloud.ServiceClient, d *schema.ResourceData) (err error) {
+	var logicalDisks []nodes.LogicalDisk
+	var raid *baremetalhost.RAIDConfig
+
+	raidConfig := d.Get("raid_config").(string)
+	if raidConfig == "" {
+		return nil
+	}
+
+	err = json.Unmarshal([]byte(raidConfig), &raid)
+	if err != nil {
+		return
+	}
+
+	err = checkRAIDConfigure(d.Get("raid_interface").(string), raid)
+	if err != nil {
+		return
+	}
+
+	// Build target for RAID configuration steps
+	logicalDisks, err = ironic.BuildTargetRAIDCfg(raid)
+	if len(logicalDisks) == 0 || err != nil {
+		return
+	}
+
+	// Set root volume
+	if len(d.Get("root_device").(map[string]interface{})) == 0 {
+		logicalDisks[0].IsRootVolume = new(bool)
+		*logicalDisks[0].IsRootVolume = true
+	} else {
+		log.Printf("rootDeviceHints is used, the first volume of raid will not be set to root")
+	}
+
+	// Set target for RAID configuration steps
+	return nodes.SetRAIDConfig(
+		client,
+		d.Id(),
+		nodes.RAIDConfigOpts{LogicalDisks: logicalDisks},
+	).ExtractErr()
+}
+
+// buildBIOSSettings builds bios settings for BIOS clean steps
+func buildBIOSSettings(d *schema.ResourceData, firmwareConfig *baremetalhost.FirmwareConfig) (settings []map[string]string, err error) {
+	driver := d.Get("driver").(string)
+	driverInfo := d.Get("driver_info").(map[string]interface{})
+	driverAddress := strings.Join([]string{driver, "address"}, "_")
+
+	address := strings.Join([]string{driver, driverInfo[driverAddress].(string)}, "://")
+	acc, err := bmc.NewAccessDetails(address, false)
+	if err != nil {
+		return nil, err
+	}
+
+	settings, err = acc.BuildBIOSSettings(firmwareConfig)
+	if err != nil {
+		return nil, err
+	}
+	return
+}
+
+// buildManualCleaningSteps builds the clean steps for RAID and BIOS configuration
+func buildManualCleaningSteps(d *schema.ResourceData) (cleanSteps []nodes.CleanStep, err error) {
+	var targetRaid *baremetalhost.RAIDConfig
+	var firmware *baremetalhost.FirmwareConfig
+
+	raidInterface := d.Get("raid_interface").(string)
+
+	raidConfig := d.Get("raid_config").(string)
+	if raidConfig != "" {
+		if err = json.Unmarshal([]byte(raidConfig), &targetRaid); err != nil {
+			return nil, err
+		}
+
+		// Build raid clean steps
+		raidCleanSteps, err := ironic.BuildRAIDCleanSteps(raidInterface, targetRaid, nil)
+		if err != nil {
+			return nil, err
+		}
+		cleanSteps = append(cleanSteps, raidCleanSteps...)
+	}
+
+	biosSetings := d.Get("bios_settings").(string)
+	if biosSetings != "" {
+		if err = json.Unmarshal([]byte(biosSetings), &firmware); err != nil {
+			return nil, err
+		}
+
+		settings, err := buildBIOSSettings(d, firmware)
+		if err != nil {
+			return nil, err
+		}
+
+		if len(settings) != 0 {
+			cleanSteps = append(
+				cleanSteps,
+				nodes.CleanStep{
+					Interface: "bios",
+					Step:      "apply_configuration",
+					Args: map[string]interface{}{
+						"settings": settings,
+					},
+				},
+			)
+		}
+	}
+
+	return
+}
+
+func checkRAIDConfigure(raidInterface string, raid *baremetalhost.RAIDConfig) error {
+	switch raidInterface {
+	case noRAIDInterface:
+		if raid != nil && (len(raid.HardwareRAIDVolumes) != 0 || len(raid.SoftwareRAIDVolumes) != 0) {
+			return fmt.Errorf("raid settings are defined, but the node's driver %s does not support RAID", raidInterface)
+		}
+	case softwareRAIDInterface:
+		if raid != nil && len(raid.HardwareRAIDVolumes) != 0 {
+			return fmt.Errorf("node's driver %s does not support hardware RAID", raidInterface)
+		}
+	default:
+		if raid != nil && len(raid.HardwareRAIDVolumes) == 0 && len(raid.SoftwareRAIDVolumes) != 0 {
+			return fmt.Errorf("node's driver %s does not support software RAID", raidInterface)
+		}
+	}
+	return nil
+}
diff --git a/ironic/workflow.go b/ironic/workflow.go
index 6a44fb48..be5b6ad9 100644
--- a/ironic/workflow.go
+++ b/ironic/workflow.go
@@ -285,10 +285,11 @@ func (workflow *provisionStateWorkflow) buildProvisionStateOpts(target nodes.Tar
 		}
 	}
 	if target == "clean" {
-		opts.CleanSteps = []nodes.CleanStep{}
-		// TODO if we want to actually clean, then we need clean_steps
-		// currently bmo does quite a lot of work to get raid cleaning working.
-		// https://github.com/metal3-io/baremetal-operator/blob/master/pkg/provisioner/ironic/ironic.go#L1249-L1292
+		if workflow.configDrive != nil {
+			opts.CleanSteps = workflow.configDrive.([]nodes.CleanStep)
+		} else {
+			opts.CleanSteps = []nodes.CleanStep{}
+		}
 	}
 
 	return &opts, nil
-- 
2.26.3

